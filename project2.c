/*********************************************
Project : Test software
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>

#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include "defs.h" 
#include <stdint.h>   

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

/*
 * Timer 1 Output Compare A interrupt is used to blink LED
 */
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
LED1 = ~LED1; // invert LED    
}                                  

void delay_350ns()
{
    #asm
        
        
        
       
    #endasm
    
}

void delay_600ns()
{
    #asm
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
    #endasm
    
}

void delay_700ns()
{
    #asm
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
       
        
    #endasm
    
}

void delay_800ns()
{
    #asm
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
         
    #endasm
    
}


/*
void ALL_LEDS(uint32_t color)
{
    ///USING PD7, (21)
     uint32_t i=0;
     uint8_t j=0;
     uint32_t temp;
    //RESET SIGNAL 0 for >= 50us ^^^^^|__|INFO
     temp=color; 
    
    //temp takes 24 bit  
    //we need to send 24 bits for 64 leds after reset signal
    for(i=0;i<LED_NR;i++)
    {   
      
      
      //now for each bit of the color
         
            //we check if LSB is 1/0    (I still need to check if color information is sent with lsb first)
            if(temp & 1)
          {
            //send 1 impulse (from datasheet)
            //0.7 us high 0.6 us low   |^^\__
            
            
            PORTD |= (1 << PORTD7);
            //DELAY 0.7 us 
            //delay_700ns();
            #asm
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            #endasm

            
            PORTD &= ~(1 << PORTD7);
            //DELAY 0.6 us  
                
            //delay_600ns();
          }
            else
          { 
            //send 0 impulse (from datasheet)
            //0.35 us high 0.8 us low   |^\___
             PORTD |= (1 << PORTD7);
            //DELAY 0.35 us 
             #asm
            nop
            nop
            nop
            nop
            nop
            #endasm
            //delay_350ns();
            PORTD &= ~(1 << PORTD7);
            //DELAY 0.8 us
                  
          //we shift temp right so that we can check another bit, the new LSB  
          temp = temp >> 1;
      } 
      
       
    }
     //WE NEED STOP CONDITION
     
    //DELAYS ARE WIP, WILL BE CALIBRATED USING LOGIC ANALYSER 
    
    //KEEP IN MIND 150ns tolerance for delays
}

*/
void LED_WHT_4TESTING()
{      
       
        //bit23
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit22
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit21
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit20
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit19
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit18
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit17
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit16
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit15
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit14
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit13
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit12
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit11
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit10
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit9
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit8
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit7
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit6
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit5
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit4
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit3
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit2
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit1
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit0
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();

}

void LED_WHT()
{      
       
        //bit23
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit22
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit21
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit20
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit19
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit18
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit17
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit16
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit15
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit14
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit13
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit12
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit11
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit10
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit9
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit8
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit7
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit6
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit5
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit4
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit3
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit2
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit1
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit0
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();

}

void LED_GRN()
{      
       
        //bit23
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit22
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit21
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit20
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit19
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit18
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit17
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit16
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit15
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit14
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit13
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit12
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit11
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit10
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit9
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit8
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit7
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit6
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit5
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit4
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit3
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit2
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit1
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit0
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();

}

void LED_YLW()
{      
       
        //bit23
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit22
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit21
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit20
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit19
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit18
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit17
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit16
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit15
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();  
        
        //bit14
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();  
        
        //bit13
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();  
        
        //bit12
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit11
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit10
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();  
        
        //bit9
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit8
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit7
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit6
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit5
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit4
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit3
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit2
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit1
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit0
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();

}

void LED_RED()
{
//bit23
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit22
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit21
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit20
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit19
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit18
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit17
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit16
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit15
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit14
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit13
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit12
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit11
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit10
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit9
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit8
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit7
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit6
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit5
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit4
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit3
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit2
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit1
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit0
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();

}

void LED_BLU()
{
   //bit23
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit22
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit21
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit20
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit19
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit18
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit17
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit16
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit15
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit14
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit13
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit12
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit11
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit10
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns(); 
        
        //bit9
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit8
        PORTD |= (1 << PORTD7);
        delay_350ns();
        PORTD &= ~(1 << PORTD7); 
        delay_800ns();
        
        //bit7
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns(); 
        
        //bit6
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit5
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit4
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit3
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit2
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit1
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();
        
        //bit0
        PORTD |= (1 << PORTD7);
        delay_700ns();
        PORTD &= ~(1 << PORTD7); 
        delay_600ns();

}

void ALL_LEDS_WHITE()
{
 
 uint8_t l=0;     

     for(l=0;l<LED_NR;l++)
     {
        LED_WHT();//if we remove last delay of 23th bit because for will add delay
     }
}
//OR

void all_white()
{
        //row1
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); 
        //row2
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); 
        //row3
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT();
        //row4 
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT();
        //row5
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT();
        //row6 
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT();
        //row7 
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT();
        //row8 
        LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT(); LED_WHT();   
        
}




/*
 * main function of program
 */
void main (void)
{          
unsigned char temp,i;

	Init_initController();  // this must be the first "init" action/call!
	#asm("sei")             // enable interrupts
	LED1 = 1;           	// initial state, will be changed by timer 1

	while(TRUE)
	{
		wdogtrig();	        // call often else processor will reset
		if(rx_counter0)     // if a character is available on serial port USART0
		{
			temp = getchar();
			if(temp == '?') 
				printf("\r\nSwVersion:%d.%d\r\n", SW_VERSION/10, SW_VERSION%10); 
			else
				putchar(temp+1);		// echo back the character + 1 ("a" becomes "b", etc)   
		}             

        if(SW1 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(SW1 == 0)    
            {                // LED will blink slow or fast
                while(SW1==0)
                    wdogtrig();    // wait for release
                // alternate between values and values/4 for OCR1A register
                // 4C40H / 4 = 1310H
                // new frequency = old frequency * 4
                if(OCR1AH == 0x4C)  
                    {TCNT1H=0; TCNT1L=0; OCR1AH = 0x13; OCR1AL = 0x10;}
                else     
                    {TCNT1H=0; TCNT1L=0; OCR1AH = 0x4C; OCR1AL = 0x40;}            
            }                
        }                                       
          LED_WHT();
        // measure time intervals on oscilloscope connected to pin TESTP
       
     }   
            
           
             // may check accuracy of 1us interval on oscilloscope     
        
          
    
  

            
}// end main loop 


